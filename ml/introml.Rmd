---
title: "IntroML"
author: "Jai Jeffryes"
date: "12/9/2019"
output:
  html_document:
    code_download: yes
    code_folding: hide
    highlight: pygments
    number_sections: yes
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(caret)
```

# Dependencies
- You'll need the `ellipse` package for plotting ellipses in `featurePlot()`.
- `randomForest`.

# Introduction
A getting-acquainted, *Hello, World* machine learning project employing the `iris` data set.

References:

1. [Your First Machine Learning Project in R Step-By-Step](https://machinelearningmastery.com/machine-learning-in-r-step-by-step/).
1. [How to Use a Machine Learning Checklist to Get Accurate Predictions, Reliably](https://machinelearningmastery.com/machine-learning-checklist/).
1. [The Process](http://machinelearningmastery.com/process-for-working-through-machine-learning-problems/).
1. [What is Data Mining and KDD?](http://machinelearningmastery.com/what-is-data-mining-and-kdd/).
1. [The `caret` Package](https://topepo.github.io/caret/). Home page by Max Kuhn.

- Define Problem.
- Prepare Data.
- Evaluate Algorithms.
- Improve Results.
- Present Results.

# Description
Summarization of iris data.

- Numeric data.
- Classification. Unsupervised.
- Multi-class or multi-nominal.

Since we have class data, we observe that this data set is **labelled**.

## `caret`
The caret package provides a consistent interface into hundreds of machine learning algorithms and provides useful convenience methods for data visualization, data resampling, model tuning and model comparison, among other features. It’s a must have tool for machine learning projects in R.

# Load data
Use a generic name for the dataset so you can copy and paste code later.
```{r}
data(iris)
dataset <- iris
rm(iris)
gc()
```

## Create validation dataset
```{r}
# Create a list of 80% of the rows in the original dataset we can
# use for training.
set.seed(7)
training_index <- createDataPartition(dataset$Species, p=0.80, list=FALSE)
# Select 20% of the data for validation.
validation <- dataset[-training_index,]
# Use the remaining 80% of data to training and testing the models
dataset <- dataset[training_index,]
```

# Summarize
- Dimensions of the dataset.
- Types of the attributes.
- Peek at the data itself.
- Levels of the class attribute.
- Breakdown of the instances in each class.
- Statistical summary of all attributes.

```{r}
# dimensions of dataset
dim(dataset)

# list types for each attribute
sapply(dataset, class)

str(dataset)

# take a peek at the first 5 rows of the data
head(dataset)

# list the levels for the class
levels(dataset$Species)

# summarize the class distribution
percentage <- prop.table(table(dataset$Species)) * 100
cbind(freq=table(dataset$Species), percentage=percentage)

# summarize attribute distributions
summary(dataset)
```

# Visualize
We are going to look at two types of plots:

1. Univariate plots to better understand each attribute.
1. Multivariate plots to better understand the relationships between attributes.

## Univariate
It is helpful with visualization to have a way to refer to just the input attributes and just the output attributes. Let’s set that up and call the inputs attributes x and the output attribute (or class) y.

```{r}
# split input and output
x <- dataset[,1:4]
y <- dataset[,5]
```

Given that the input variables are numeric, we can create box and whisker plots of each.

I like to see the distributions as histograms, too.

```{r}
par.old <- par(no.readonly = TRUE)

# boxplot for each attribute on one image
par(mfrow=c(1,4))
  for(i in 1:4) {
  boxplot(x[,i], main=names(iris)[i])
  }

# histogram for each attribute.
is_col_numeric <- sapply(dataset, class) == "numeric"

par(par.old)
for(i in 1:sum(is_col_numeric)) {
    hist(x[, i], main = names(iris)[i], xlab = "Units")
}
```

We can also create a barplot of the Species class variable to get a graphical representation of the class distribution (generally uninteresting in this case because they’re even).

```{r}
# barplot for class breakdown
plot(y)
```

## Multivariate
Now we can look at the interactions between the variables.

First let’s look at scatterplots of all pairs of attributes and color the points by class. In addition, because the scatterplots show that points for each class are generally separate, we can draw ellipses around them.

`featurePlot()` comes from `caret` and it is a wrapper for `lattice` plotting of predictor variables.

```{r}
# scatterplot matrix
featurePlot(x=x, y=y, plot="ellipse")
```

We can also look at box and whisker plots of each input variable again, but this time broken down into separate plots for each class. This can help to tease out obvious linear separations between the classes.

This is useful to see that there are clearly different distributions of the attributes for each class value.

```{r}
# box and whisker plots for each attribute
featurePlot(x=x, y=y, plot="box")
```

Next we can get an idea of the distribution of each attribute, again like the box and whisker plots, broken down by class value. Sometimes histograms are good for this, but in this case we will use some probability density plots to give nice smooth lines for each distribution.

```{r}
# density plots for each attribute by class value
scales <- list(x=list(relation="free"), y=list(relation="free"))
featurePlot(x=x, y=y, plot="density", scales=scales)
```

# Evaluate algorithms
Now it is time to create some models of the data and estimate their accuracy on unseen data.

Here is what we are going to cover in this step:

- Set-up the test harness to use 10-fold cross validation.
- Build 5 different models to predict species from flower measurements
- Select the best model.

## Test harness
We will run 10-fold cross validation to estimate accuracy.

This will split our dataset into 10 parts, train in 9 and test on 1 and release for all combinations of train-test splits. We will also repeat the process 3 times for each algorithm with different splits of the data into 10 groups, in an effort to get a more accurate estimate.

```{r}
# Run algorithms using 10-fold cross validation
control <- trainControl(method="cv", number=10)
metric <- "Accuracy"
```

We are using the metric of “Accuracy” to evaluate models. This is a ratio of the number of correctly predicted instances divided by the total number of instances in the dataset multiplied by 100 to give a percentage (e.g. 95% accurate). We will use the metric variable when we build and evaluate each model next.

## Build models
We don’t know which algorithms would be good on this problem or what configurations to use. We get an idea from the plots that some of the classes are partially linearly separable in some dimensions, so we are expecting generally good results.

Let’s evaluate 5 different algorithms:

- Linear Discriminant Analysis (LDA)
- Classification and Regression Trees (CART).
- k-Nearest Neighbors (kNN).
- Support Vector Machines (SVM) with a linear kernel.
- Random Forest (RF)

This is a good mixture of simple linear (LDA), nonlinear (CART, kNN) and complex nonlinear methods (SVM, RF). We reset the random number seed before reach run to ensure that the evaluation of each algorithm is performed using exactly the same data splits. It ensures the results are directly comparable.

Let’s build our five models.

```{r}
# a) linear algorithms
set.seed(7)
fit.lda <- train(Species~., data=dataset, method="lda", metric=metric, trControl=control)
# b) nonlinear algorithms
# CART
set.seed(7)
fit.cart <- train(Species~., data=dataset, method="rpart", metric=metric, trControl=control)
# kNN
set.seed(7)
fit.knn <- train(Species~., data=dataset, method="knn", metric=metric, trControl=control)
# c) advanced algorithms
# SVM
set.seed(7)
fit.svm <- train(Species~., data=dataset, method="svmRadial", metric=metric, trControl=control)
# Random Forest
set.seed(7)
fit.rf <- train(Species~., data=dataset, method="rf", metric=metric, trControl=control)
```

# Select best model
We now have 5 models and accuracy estimations for each. We need to compare the models to each other and select the most accurate.

We can report on the accuracy of each model by first creating a list of the created models and using the summary function.

We can see the accuracy of each classifier and also other metrics like Kappa.

```{r}
# summarize accuracy of models
results <- resamples(list(lda=fit.lda, cart=fit.cart, knn=fit.knn, svm=fit.svm, rf=fit.rf))
summary(results)
```

We can also create a plot of the model evaluation results and compare the spread and the mean accuracy of each model. There is a population of accuracy measures for each algorithm because each algorithm was evaluated 10 times (10 fold cross validation).

```{r}
# compare accuracy of models
dotplot(results)
```

The results for just the LDA model can be summarized.

```{r}
# summarize Best Model
print(fit.lda)
```

# Predict
The LDA was the most accurate model. Now we want to get an idea of the accuracy of the model on our validation set.

This will give us an independent final check on the accuracy of the best model. It is valuable to keep a validation set just in case you made a slip during such as overfitting to the training set or a data leak. Both will result in an overly optimistic result.

We can run the LDA model directly on the validation set and summarize the results in a confusion matrix.

```{r}
# estimate skill of LDA on the validation dataset
predictions <- predict(fit.lda, validation)
confusionMatrix(predictions, validation$Species)
```

We can see that the accuracy is 100%. It was a small validation dataset (20%), but this result is within our expected margin of 97% +/-4% suggesting we may have an accurate and a reliably accurate model.